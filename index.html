<!-- 
    Sounds on creative commons 0 license (public domain):
        oof: https://freesound.org/people/fotoshop/sounds/47356/
        wrong: https://freesound.org/people/Raclure/sounds/483598/
        yay: https://freesound.org/people/Higgs01/sounds/428156/

    Digital Dream font by Jakob Fischer (free for personal and commercial use): 
        https://www.1001fonts.com/digital-dream-font.html
        www.pizzadude.dk

    Heart SVG by Sergio Peña
        https://codepen.io/sergixnet/details/eZVpXa
 -->
<!DOCTYPE html>
<html>
    <head>
        <title>Time flies!</title>
        <link rel="preload" href="./assets/digitaldream.ttf" as="font" type="font/ttf" crossorigin />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <meta charset="utf-8" />
        <link rel="stylesheet" href="./css/reset.css" />
        <link rel="stylesheet" href="./css/clock.css" />
        <link rel="stylesheet" href="./css/styles.css" />
        <style>
            @font-face {
                font-family: "Digital Dream";
                src: url("./assets/digitaldream.ttf");
                font-display: block;
            }

            html,
            body {
                overflow: hidden;
                font-family: Verdana, Geneva, Tahoma, sans-serif;
                background-color: var(--saffron);
                color: var(--charcoal);
            }

            :root {
                --default-radius: 5rem;
                --default-diameter: calc(var(--default-radius) * 2);
                --clock-margin: 0 5rem;

                /* colors */
                /* palette link: https://coolors.co/palette/264653-2a9d8f-e9c46a-f4a261-e76f51 */
                --charcoal: hsla(197, 37%, 24%, 1);
                --persian-green: hsla(173, 58%, 39%, 1);
                --persian-green-lighter: hsla(173, 58%, 59%, 1);
                --saffron: hsla(43, 74%, 66%, 1);
                --sandy-brown: hsla(27, 87%, 67%, 1);
                --burnt-sienna: hsla(12, 76%, 61%, 1);
                --burnt-sienna-darker: hsla(12, 76%, 41%, 1);

                font-size: 12px;
            }

            @media (max-width: 1128px) {
                :root {
                    font-size: 9px;
                }
            }

            @media (max-width: 938px) {
                :root {
                    font-size: 7.5px;
                }
            }

            * {
                box-sizing: border-box;
            }
        </style>
        <script src="./js/consts.js"></script>
    </head>
    <body>
        <div class="screen main-menu-screen active">
            <div class="clock" style="width: 25rem; height: 25rem; margin: 0 auto; margin-bottom: 4rem; --radius: 8rem">
                <!-- clock slot -->
            </div>
            <h1>Time flies!</h1>
            <p style="text-align: center; padding: 2rem 5rem; font-size: 2rem">
                Find all the clocks presenting the time from the upper center of your screen. Don't let the proper
                clocks slip by. You'll loose your hearts!
            </p>
            <button class="main-button" onclick="showDifficultyScreen()">Play</button>
        </div>

        <div class="screen difficulty-screen" data-chosen="normal">
            <h1>Choose difficulty</h1>
            <div class="infos">
                <div data-difficulty="normal" class="difficulty-info">
                    Just normal mode. Clicking wrong clocks won't cause you trouble.
                </div>
                <div data-difficulty="hard" class="difficulty-info">
                    Stay alert - clicking on wrong clocks will cause you trouble.
                </div>
            </div>

            <div style="display: flex; flex-direction: column; gap: 1rem; margin: 0 auto">
                <button
                    data-difficulty="normal"
                    class="digital-font button-with-icon"
                    onclick="DIFFICULTY_SCREEN_EVENT_HANDLERS.onDifficultySelect(this)"
                >
                    Normal
                </button>
                <button
                    data-difficulty="hard"
                    class="digital-font button-with-icon"
                    onclick="DIFFICULTY_SCREEN_EVENT_HANDLERS.onDifficultySelect(this)"
                >
                    Hard
                </button>
            </div>

            <hr style="width: 80%; border: none; border-bottom: 0.2rem solid var(--charcoal); margin: 2rem auto" />

            <button class="main-button button-with-icon" onclick="DIFFICULTY_SCREEN_EVENT_HANDLERS.onPlay(this)">
                <svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 20 20">
                    <path fill="#274754" d="m4 4l12 6l-12 6z" />
                </svg>
                Play
            </button>
            <button class="secondary-button button-with-icon" onclick="showScreen('main-menu')"><- Back</button>
        </div>

        <div class="screen game-screen">
            <div class="top-bar">
                <div class="hp"></div>
                <div class="time">3:15</div>
                <div class="points"><span class="value">0</span><span>points</span></div>
                <button id="pause-button" type="button" onclick="togglePause()">
                    <svg
                        version="1.1"
                        xmlns="http://www.w3.org/2000/svg"
                        viewbox="0 0 60 100"
                        style="width: 3rem; height: 3rem"
                    >
                        <rect width="20" height="100" x="0" y="0" />
                        <rect width="20" height="100" x="40" y="0" />
                    </svg>
                </button>
            </div>
            <div class="tracks-wrapper">
                <div class="tracks"></div>
            </div>
            <span class="round-announcement">Round 1</span>
        </div>

        <div id="looser-popup" class="popup" style="display: none">
            <div id="banner-container" style="width: 300px; height: 250px; margin: 0 auto; margin-bottom: 1rem"></div>
            <div>You reached round #<span id="round-number"></span></div>
            <div>Your Score: <span id="score">0</span></div>
            <div id="highscore" style="display: none">
                <div>You have beaten your previous highscore of <span id="prev-hs">0</span></div>
            </div>
            <div id="try-again-wrapper">
                <button class="main-button" onclick="tryAgain(currentDifficultyCfg)">Try again</button>
                <button class="secondary-button" onclick="showDifficultyScreen()">Change difficulty</button>
            </div>
        </div>

        <div id="pause-popup" class="popup" style="display: none">
            <div>
                <h2>Pause</h2>
                <button class="main-button" onclick="backToMenu()">Back to menu</button>
                <button class="secondary-button" onclick="togglePause()">Close</button>
            </div>
        </div>

        <script type="module">
            import { randomInt, instantiateTemplate, playAudio, $, $$, showEl, hideEl } from "./js/utils.mjs";
            import { instantiateClock } from "./js/core.mjs";

            const yaySfx = new Audio("./assets/yay.wav");
            const wrongSfx = new Audio("./assets/wrong.mp3");
            const oofSfx = new Audio("./assets/oof.wav");

            const hpElement = $(".hp");
            const pointsElement = $(".points .value");
            const looserElement = $("#looser-popup");
            const rowsWrapper = $(".tracks");
            const time = $(".time");

            const mainMenu = $(".main-menu-screen");
            const gameScreen = $(".game-screen");
            const difficultyScreen = $(".difficulty-screen");

            const DIFFICULTY_LEVELS = ["normal", "hard"];

            function getDescriptionElFor(difficulty) {
                return $(`.difficulty-info[data-difficulty="${difficulty}"]`);
            }

            function addDifficultyScreenStyles() {
                const exists = $("style#difficulty-screen");
                if (exists) {
                    return;
                }

                const s = document.createElement("style");
                s.id = "difficulty-screen";
                let difficultyScreenStyles = "";
                for (const d of DIFFICULTY_LEVELS) {
                    difficultyScreenStyles += `[data-chosen="${d}"] button[data-difficulty="${d}"]::before { content: "x" }\n`;
                    difficultyScreenStyles += `[data-chosen="${d}"] .difficulty-info[data-difficulty="${d}"] { display: block; }\n`;
                }
                s.textContent = difficultyScreenStyles;
                document.head.appendChild(s);
            }

            // setup event handlers for difficulty screen
            function setupDifficultyScreen() {
                addDifficultyScreenStyles();

                const descriptions = $$(".difficulty-info[data-difficulty]");

                window.DIFFICULTY_SCREEN_EVENT_HANDLERS = {
                    onDifficultySelect: (btn) => {
                        $(".difficulty-screen").dataset.chosen = btn.dataset.difficulty;
                    },
                    onPlay: (btn) => {
                        const difficulty = btn.closest("[data-chosen]").dataset.chosen;
                        window.currentDifficultyCfg = DIFFICULTY_CONFIGS[difficulty.toUpperCase()];
                        nextRound();
                    },
                };
            }

            setupDifficultyScreen();

            const MINUTES_EASY = [0, 15, 30, 45];
            // const MINUTES_HARD = [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55];
            // const MINUTES_IMPOSSIBLE = Array(60)
            //     .fill()
            //     .map((_, i) => i);
            const TRACKS_NUM = 6;

            const BASE_TRACK_ANIMATION_TIME = 33000;
            const STOP_SPEEDUP_AT_ROUND = 20;
            const SPEEDUP_STEP = 350;

            /**
             * @typedef { "main-menu" | "difficulty" | "game" } Screen
             */

            function getInitialGameState() {
                // TODO: move the rest of the fragmented state inside here
                return {
                    /** @type {Screen} */
                    screen: "main-menu",
                    isPaused: false,
                    /** @type {Animation[]} */
                    trackAnimations: [],
                    /**
                     * How many wrong clicks were made in a row. After reaching value of 2, the player should be punished with -1 HP
                     * and the counter should be reset to 0.
                     */
                    failsInARow: 0,
                };
            }

            /** @typedef {ReturnType<typeof getInitialGameState>} GameState */

            /** @type {GameState} */
            const GAME_STATE = getInitialGameState();

            /** @param {GameState} gameState */
            function pause(gameState) {
                if (gameState.screen !== "game") return;
                gameState.isPaused = true;
                for (const anim of gameState.trackAnimations) {
                    anim.pause();
                }
            }

            /** @param {GameState} gameState */
            function unPause(gameState) {
                if (gameState.screen !== "game") return;
                gameState.isPaused = false;
                for (const anim of gameState.trackAnimations) {
                    anim.play();
                }
            }

            /** @param {GameState} gameState */
            function togglePause(gameState) {
                if (gameState.screen !== "game") return;
                if (gameState.isPaused) {
                    unPause(gameState);
                    $("#pause-popup").style.display = "none";
                } else {
                    pause(gameState);
                    $("#pause-popup").style.display = null;
                }
            }

            window.togglePause = () => togglePause(GAME_STATE);

            /**
             * @param {GameState} gameState
             * @param {Screen} screen
             */
            function changeScreen(gameState, screen) {
                gameState.screen = screen;
                const screens = $$(".screen");

                for (const s of screens) {
                    s.classList.remove("active");
                }

                $(`.${screen}-screen`).classList.add("active");
            }

            window.showScreen = (name) => changeScreen(GAME_STATE, name);
            window.backToMenu = () => {
                changeScreen(GAME_STATE, "main-menu");
                // simple way of stopping the game
                $(".tracks").innerHTML = "";
                // some popups might need some internal elements to hide also
                $$(".popup").forEach((x) => (x.style.display = "none"));
            };

            function getTrackAnimationDuration(round) {
                const base = BASE_TRACK_ANIMATION_TIME - SPEEDUP_STEP * Math.min(round, STOP_SPEEDUP_AT_ROUND);
                return base + randomInt(5000) - 2500; // +/- 2500
            }

            const BASE_MAX_CLOCKS_PER_COLUMN = 1;
            const MAX_CLOCKS_PER_COLUMN_STEP = 0.2;
            const AT_MOST_CLOCKS_PER_COLUMN = 3;

            function getClocksPerColumn(round) {
                return Math.min(
                    AT_MOST_CLOCKS_PER_COLUMN,
                    Math.floor(BASE_MAX_CLOCKS_PER_COLUMN + MAX_CLOCKS_PER_COLUMN_STEP * round)
                );
            }

            let round = 1;
            let goalClocksCount = 0;
            let goneProperClocksCount = 0;

            function fillHpElement(hp) {
                const instance = instantiateTemplate("#t-heart");
                const elements = [instance];
                for (let i = 1; i < hp; i++) {
                    elements.push(instance.cloneNode(true));
                }
                hpElement.innerHTML = "";
                hpElement.append(...elements);
            }

            function closeYouLost() {
                $("#highscore").style.display = "none";
                looserElement.style.display = "none";
            }

            function showYouLost(points) {
                looserElement.style.display = null;

                $("#round-number").innerHTML = round;
                $("#score").innerHTML = points;

                const lsKey = LS_KEYS[`HS_${window.currentDifficultyCfg.name}`.toUpperCase()];

                const prevhs = localStorage.getItem(lsKey);
                if (prevhs === null) {
                    localStorage.setItem(lsKey, points);
                } else if (prevhs < points) {
                    $("#prev-hs").innerHTML = prevhs;
                    $("#highscore").style.display = null;
                    localStorage.setItem(lsKey, points);
                }
            }

            function resetTracks(tracks) {
                tracks.forEach((t) => (t.innerHTML = ""));
            }

            function reinstantiateTracks() {
                rowsWrapper.innerHTML = "";
                const newTracksInstance = instantiateTemplate("#t-tracks");
                rowsWrapper.append(...newTracksInstance.children);
            }

            function decreaseHP(hp, points, tracks) {
                playAudio(oofSfx);
                hp--;
                fillHpElement(hp);
                if (hp === 0) {
                    showYouLost(points);
                    resetTracks(tracks);
                }
                return hp;
            }

            function increasePoints(points) {
                playAudio(yaySfx);
                points++;
                goneProperClocksCount++;
                pointsElement.innerHTML = points;

                if (goneProperClocksCount == goalClocksCount) {
                    setTimeout(() => {
                        round = nextRound(points, round);
                    });
                }

                return points;
            }

            function isOutOfScreen(clock) {
                if (clock.dataset.disabled) return false;

                const bounds = clock.getBoundingClientRect();
                return (
                    (clock.dataset.reverse && bounds.left > window.innerWidth) ||
                    (!clock.dataset.reverse && bounds.right < 0)
                );
            }

            /**
             * @param { { punishOnMistake: boolean } } cfg
             */
            function startRound(roundNum, trackLength, goal, carriedPoints = 0, cfg) {
                const { punishOnMistake } = cfg;

                goalClocksCount = 0;
                goneProperClocksCount = 0;

                let hp = 3;
                let points = carriedPoints;

                const { hour: ghour, minutes: gminutes } = goal;

                time.innerHTML = `${ghour}:${gminutes.toString().padStart(2, "0")}`;

                const matrixRows = Array(TRACKS_NUM)
                    .fill()
                    .map(() => Array(trackLength).fill(0));

                const clocksPerColumn = getClocksPerColumn(round);

                // Losuję dla każdej kolumny, w którym wierszu (i w ilu) ma się znaleźć zegarek.
                // Czyli dla każdej kolumny co najwyżej jeden wiersz będzie miał zegarek
                const clockCellsSet = new Set();
                for (let i = 0; i < trackLength; i++) {
                    const count = randomInt(clocksPerColumn) + 1; // [0..1] + 1 => [1..2]

                    for (let j = 0; j < count; j++) {
                        // W teorii możemy count razy wylosować ten sam row.
                        const row = randomInt(TRACKS_NUM);
                        matrixRows[row][i] = 1;
                        clockCellsSet.add(`${row},${i}`);
                    }
                }

                let goalCells = new Set(clockCellsSet);
                for (let i = goalCells.size; i > 3; i--) {
                    goalCells.delete([...goalCells.values()][randomInt(goalCells.size)]);
                }

                for (const g of goalCells) {
                    const [row, col] = g.split(",");
                    matrixRows[Number(row)][Number(col)] = 2;
                }

                const empty = document.createElement("div");
                empty.className = "empty";

                fillHpElement(hp);

                reinstantiateTracks();
                const tracks = document.querySelectorAll(".track");

                function onClockGoneOffScreen(intervId) {
                    clearInterval(intervId);
                    hp = decreaseHP(hp, points, tracks);
                    goneProperClocksCount++;
                    if (goneProperClocksCount == goalClocksCount && hp > 0) {
                        round = nextRound(points, round);
                    }
                }

                // clocks with goal time that need to be checked if they made it through the entire screen
                const clocksToCheckOffscreen = new Set();

                goalClocksCount = goalCells.size;
                matrixRows.forEach((row, idx) => {
                    for (const col of row) {
                        let clockClassName = "game-clock";
                        if (roundNum >= cfg.vertWobbleStartAt && Math.random() < 0.3) {
                            clockClassName += " wobble";
                        }

                        if (col === 1) {
                            const hour = Math.floor(Math.random() * 12) + 1;
                            const minutesIdx = Math.floor(Math.random() * MINUTES_EASY.length);
                            const minutes = MINUTES_EASY[minutesIdx];
                            const clock = instantiateClock(hour, minutes, { className: clockClassName });
                            tracks[idx].appendChild(clock);

                            // There's also possibility that a "goal clock" will be generated here.
                            if (hour === ghour && minutes === gminutes) {
                                clocksToCheckOffscreen.add(clock);

                                const intervId = setInterval(() => {
                                    if (isOutOfScreen(clock)) {
                                        onClockGoneOffScreen(intervId);
                                    }
                                }, 16);

                                goalClocksCount++;
                            }
                        } else if (col === 2) {
                            const clock = instantiateClock(ghour, gminutes, { className: clockClassName });
                            tracks[idx].appendChild(clock);
                            clocksToCheckOffscreen.add(clock);

                            // I had problems with observer, so I went with the setInterval method
                            const intervId = setInterval(() => {
                                if (isOutOfScreen(clock)) {
                                    onClockGoneOffScreen(intervId);
                                }
                            }, 16);
                        } else {
                            tracks[idx].appendChild(empty.cloneNode());
                        }
                    }
                });

                function setupTracks(roundNumber) {
                    const reverseTracksIndices = (() => {
                        if (roundNumber >= 18) {
                            const set = new Set([randomInt(6), randomInt(6), randomInt(6)]);
                            return [...set];
                        }
                        if (roundNumber >= 11) {
                            const set = new Set([randomInt(6), randomInt(6)]);
                            return [...set];
                        }
                        if (roundNumber >= 5) {
                            return [randomInt(6)];
                        }
                        return [];
                    })(round);

                    for (let i = 0; i < tracks.length; i++) {
                        const track = tracks[i];

                        let initialTranslate, goalTranslate;

                        if (reverseTracksIndices.includes(i)) {
                            // console.log(`track ${i} is reverse`);
                            initialTranslate = `translateX(calc(-${randomInt(5)}rem - ${Math.ceil(
                                track.getBoundingClientRect().width
                            )}px))`;
                            goalTranslate = `translateX(calc(100vw))`;
                            for (const c of track.children) c.dataset.reverse = true;
                        } else {
                            initialTranslate = `translateX(calc(100vw + ${randomInt(5)}rem))`;
                            goalTranslate = `translateX(${-Math.ceil(track.getBoundingClientRect().width)}px)`;
                        }

                        track.style.transform = initialTranslate;

                        const bounds = track.getClientRects();
                        const trackAnimation = [{ transform: initialTranslate }, { transform: goalTranslate }];
                        const duration = getTrackAnimationDuration(round);

                        const options = {
                            duration,
                            iterations: 1,
                            delay: randomInt(5000),
                        };

                        const animation = track.animate(trackAnimation, options);
                        GAME_STATE.trackAnimations.push(animation);
                    }
                }

                setupTracks(round);

                window.handleClockClick = (instance) => {
                    const hour = instance.style.getPropertyValue("--hour");
                    const minutes = instance.style.getPropertyValue("--minutes");
                    if (hour == ghour && minutes == gminutes) {
                        points = increasePoints(points);
                        // instance.parentNode.replaceChild(empty.cloneNode(), instance);
                        instance.style.visibility = "hidden";
                        instance.style.pointerEvents = "none";
                        instance.dataset.disabled = true;
                        GAME_STATE.failsInARow = 0;
                    } else {
                        playAudio(wrongSfx);
                        instance.style.setProperty("--hover-shadow-color", "red");
                        instance.addEventListener(
                            "mouseleave",
                            () => {
                                instance.style.setProperty("--hover-shadow-color", "lime");
                            },
                            { once: true }
                        );
                        GAME_STATE.failsInARow += 1;

                        if (punishOnMistake) {
                            hp = decreaseHP(hp, points, tracks);
                        } else if (GAME_STATE.failsInARow == 2) {
                            /**
                             * On normal mode the player will be punished after doing 2 wrong clicks in a row.
                             * Otherwise, normal mode doesn't make sense, since you can just click every clock and you will eventually
                             * find the correct ones and advance to the next level.
                             */
                            // TODO: move tracks and points and hp to game state
                            hp = decreaseHP(hp, points, tracks);
                            GAME_STATE.failsInARow = 0;
                        }
                    }
                };
            }

            window.showDifficultyScreen = function showDifficultyScreen() {
                closeYouLost();
                changeScreen(GAME_STATE, "difficulty");
            };

            window.play = function play({ carriedPoints = 0, cfg }) {
                // TODO: store cfg in game state
                window.currentDifficultyCfg = cfg;

                changeScreen(GAME_STATE, "game");

                const hour = randomInt(12) + 1;
                const minutes = MINUTES_EASY[randomInt(4)];
                startRound(round, 20, { hour, minutes }, carriedPoints, cfg);
            };

            window.tryAgain = function tryAgain(cfg) {
                round = 1;

                closeYouLost();

                pointsElement.innerHTML = "0";
                play({ cfg });
            };

            function nextRound(carriedPoints = 0, roundNumber = 0) {
                const element = $(".round-announcement");
                let round = roundNumber;
                round += 1;
                element.innerHTML = `Round ${round}`;
                element.classList.add("op1");
                setTimeout(() => {
                    element.classList.remove("op1");
                }, 1000);

                // Trigger time announcement animation.
                // Remove previously set class and immediately add it again in a next "tick".
                // Removing and setting in the same "tick" won't retrigger the animation.
                // TODO: The animation is not perfect, but is good enough for now. To animate exactly from the center of the screen
                // to the position of .time I'd need to use another absolutely positioned element.
                $(".time").classList.add("announce");
                setTimeout(() => {
                    $(".time").classList.remove("announce");
                }, 2700);

                play({ carriedPoints, cfg: window.currentDifficultyCfg });

                return round;
            }

            function instantiateMenuClock() {
                const date = new Date();

                const clock = instantiateClock(date.getHours() % 12, date.getMinutes(), {
                    className: "menu-clock",
                    seconds: 0,
                });

                setInterval(() => {
                    const seconds = Number(clock.style.getPropertyValue("--seconds"));
                    clock.style.setProperty("--seconds", (seconds + 1) % 60);

                    if (seconds == 59) {
                        const minutes = Number(clock.style.getPropertyValue("--minutes"));
                        clock.style.setProperty("--minutes", (minutes + 1) % 60);
                        if (minutes == 59) {
                            const hours = Number(clock.style.getPorpertyValue("--hours"));
                            clock.style.setProperty("--hours", (hours + 1) % 12);
                        }
                    }
                }, 1000);

                $(".main-menu-screen .clock").appendChild(clock);
            }

            /**
             * @param {GameState} gameState
             */
            function init(gameState) {
                addEventListener("keyup", (ev) => {
                    if (GAME_STATE.screen != "game") return;

                    if (ev.key === "Escape") {
                        togglePause(GAME_STATE);
                    }
                });

                window.addEventListener("wheel", (event) => event.preventDefault(), {
                    passive: false,
                });

                window.addEventListener("keydown", (event) => {
                    if (["ArrowUp", "ArrowDown", " "].includes(event.key)) {
                        event.preventDefault();
                    }
                });

                instantiateMenuClock();
            }

            init(GAME_STATE);
        </script>
    </body>

    <template id="t-clock">
        <div class="outer-circle" style="--hour: 8; --minutes: 15" onclick="handleClockClick(this)">
            <div class="minutes pointer"></div>
            <div class="hours pointer"></div>
            <div class="seconds pointer"></div>
        </div>
    </template>

    <template id="t-tracks">
        <div class="row">
            <div class="track"></div>
        </div>
        <div class="row">
            <div class="track"></div>
        </div>
        <div class="row">
            <div class="track"></div>
        </div>
        <div class="row">
            <div class="track"></div>
        </div>
        <div class="row">
            <div class="track"></div>
        </div>
        <div class="row">
            <div class="track"></div>
        </div>
    </template>

    <template id="t-heart">
        <svg
            version="1.1"
            xmlns="http://www.w3.org/2000/svg"
            xmlns:xlink="http://www.w3.org/1999/xlink"
            x="0px"
            y="0px"
            width="1.75em"
            height="1.75em"
            viewBox="0 0 640 480"
            xml:space="preserve"
        >
            <path
                fill="var(--burnt-sienna)"
                fill-rule="evenodd"
                stroke-width="10%"
                stroke="var(--burnt-sienna-darker)"
                stroke-linejoin="round"
                d="m212.88298,23.34021c-137.447098,-2.471161 -264.63855,212.481247 105.925735,435.340698c0.406281,-0.73114 1.968781,-0.73114 2.375031,0c382.517975,-230.048691 234.665131,-451.640178 92.625702,-434.390638c-55.372711,6.724489 -81.503326,37.45645 -93.813263,63.887968c-12.309845,-26.431519 -38.440552,-57.163479 -93.81308,-63.887968c-4.438782,-0.53927 -8.866302,-0.87019 -13.300125,-0.95006z"
            />
        </svg>
    </template>
</html>
