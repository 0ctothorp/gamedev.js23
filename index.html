<!-- 
    Sounds on creative commons 0 license (public domain):
        oof: https://freesound.org/people/fotoshop/sounds/47356/
        wrong: https://freesound.org/people/Raclure/sounds/483598/
        yay: https://freesound.org/people/Higgs01/sounds/428156/

    Digital Dream font by Jakob Fischer (free for personal and commercial use): 
        https://www.1001fonts.com/digital-dream-font.html
        www.pizzadude.dk
 -->
<!--
    TODO:
        - progresywne utrudnienia
            - każda runda odrobinę szybsza (do jakiegoś limitu)
            - zwiększanie ilości zegarków
            - później wprowadzić latanie zegarków w obie strony
            - później, albo w dodatkowym trudniejszym trybie dodać karę na pomyłki
            - w trudniejszym trybie życia mogą sie nie regenerować po przejściu rundy (albo np. co drugą rundę)
            - można też dorzucić bardziej specyficzny czas, np. 15:48 i limit na pomyłki
            - jak ktoś się pomyli, to zmienić docelową godzinę?
        - kilka trybów trudności?
            - normal
                - tak jak jest teraz
            - hard
                - pomyłki są karane utratą serca
            - impossible
                - hard + przy starcie rundy nie resetują się serca
        - upiększyć grę
            - jakieś proste i estetyczne animacje i smaczki, które uprzyjemnią granie
        - dostosowanie do mobile
            - może na mobile zegarki powinny latać z góry na dół?
 -->
<!DOCTYPE html>
<html>
    <head>
        <title>Time flies!</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="preload" href="assets/digitaldream.ttf" as="font" type="font/ttf" crossorigin />
        <style>
            @font-face {
                font-family: "Digital Dream";
                src: url("assets/digitaldream.ttf");
                font-display: block;
            }

            html,
            body {
                padding: 0;
                margin: 0;
                overflow: hidden;
                font-family: Verdana, Geneva, Tahoma, sans-serif;
            }

            :root {
                --default-radius: 4rem;
                --default-diameter: calc(var(--default-radius) * 2);
                --clock-margin: 0 5rem;
                font-size: 12px;
                box-sizing: border-box;
            }

            .row {
                padding: 1rem 0;
                overflow: hidden;
                height: var(--default-diameter);
                /* border-bottom: 1px solid red; */
            }

            .row:first-child {
                /* border-top: 1px solid red; */
            }

            .tracks {
                display: flex;
                flex-direction: column;
                justify-content: center;
            }

            .track {
                height: 100%;
                display: flex;
                width: max-content;

                /*debug*/
                /* outline: 1px solid black; */
            }

            .outer-circle {
                --diameter: calc(var(--radius) * 2);
                --pointer-width: 0.3rem;
                --hover-shadow-color: lime;
                /* width: var(--diameter);
                height: var(--diameter); */
                border-radius: 50%;
                border: 0.3rem solid black;
                position: relative;
                margin: var(--clock-margin);
                aspect-ratio: 1;
            }

            .outer-circle:hover,
            .outer-circle:hover > * {
                box-shadow: 0px 0px 5px 2px var(--hover-shadow-color);
            }

            .outer-circle:hover {
                cursor: pointer;
            }

            .long-pointer {
                height: calc(var(--radius) * 0.9);
                width: 0.2rem;
                background: black;
                position: absolute;
                bottom: 50%;
                left: 50%;
                transform: translateX(-50%) rotateZ(calc(var(--minutes) * 30deg));
                transform-origin: bottom left;
            }

            .short-pointer {
                height: calc(var(--radius) * 0.7);
                width: 0.35rem;
                background: black;
                position: absolute;
                bottom: 50%;
                left: 50%;
                transform: translateX(-50%) rotateZ(calc(var(--hour) * 30deg));
                transform-origin: bottom left;
            }

            .top-bar {
                display: flex;
                justify-content: space-around;
                align-items: center;
                font-family: "Digital Dream";
            }

            .top-bar > * {
                padding: 1rem;
            }

            .time {
                font-size: 3rem;
            }

            .points {
                font-size: 1.5rem;
            }

            .hp {
                font-size: 2rem;
            }

            .empty {
                width: var(--default-diameter);
                margin: var(--clock-margin);
            }

            #looser {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 2.5rem;
                background: white;
                padding: 2rem;
                border: 1px solid black;
                text-transform: uppercase;
                text-align: center;
            }

            .main-button {
                background: lime;
                border: 1px solid black;
                margin: 0 auto;
                display: block;
                padding: 0.5rem;
                font-size: 1.5rem;
                cursor: pointer;
            }

            #looser button {
                margin-top: 2rem;
            }

            .game-screen {
                display: flex;
                flex-direction: column;
                justify-content: space-around;
                height: 100vh;
            }

            .main-menu-screen {
                display: flex;
                flex-direction: column;
                justify-content: center;
                height: 100vh;
            }

            #looser #highscore {
                text-transform: none;
                font-size: 2rem;
            }

            .round-no {
                position: absolute;
                top: 50%;
                right: 50%;
                transform: translate(50%, -50%);
                font-size: 2rem;
                font-family: "Digital Dream";
                opacity: 0;
                pointer-events: none;
                transition: opacity 0.3s;
            }

            .op1 {
                opacity: 1;
            }
        </style>
    </head>
    <body>
        <div class="main-menu-screen">
            <p style="text-align: center; padding: 2rem 5rem; font-size: 1.5rem">
                The time flies!<br />
                Find all the clocks presenting the time from the upper center of your screen. Don't let the proper
                clocks slip by. You'll loose your hearts!
            </p>
            <button class="main-button" onclick="play()">Play</button>
        </div>

        <div class="game-screen">
            <div class="top-bar">
                <div class="hp">❤️❤️❤️</div>
                <div class="time">3:15</div>
                <div class="points"><span class="value">0</span> points</div>
            </div>
            <div class="tracks"></div>
            <span class="round-no">Round 1</span>
        </div>

        <div id="looser" style="display: none">
            <div>You lost 😥</div>
            <div id="highscore" style="display: none">
                <div>but...</div>
                <div>🎉 Congrats! You have beaten your previous highscore of <span id="prev-hs">0</span></div>
                <div>Your new highscore is <strong id="new-hs">0</strong> 🤩</div>
            </div>
            <div id="try-again-wrapper"><button class="main-button" onclick="tryAgain()">Try again</button></div>
        </div>

        <template id="t-clock">
            <div class="outer-circle" style="--radius: 4rem; --hour: 8; --minutes: 15" onclick="handleClockClick(this)">
                <div class="long-pointer"></div>
                <div class="short-pointer"></div>
            </div>
        </template>

        <template id="t-tracks">
            <div class="row">
                <div class="track"></div>
            </div>
            <div class="row">
                <div class="track"></div>
            </div>
            <div class="row">
                <div class="track"></div>
            </div>
            <div class="row">
                <div class="track"></div>
            </div>
            <div class="row">
                <div class="track"></div>
            </div>
            <div class="row">
                <div class="track"></div>
            </div>
        </template>

        <script type="module">
            import { randomInt, instantiateTemplate, qs, playAudio } from "./js/utils.js";

            const yaySfx = new Audio("assets/yay.wav");
            const wrongSfx = new Audio("assets/wrong.mp3");
            const oofSfx = new Audio("assets/oof.wav");

            const hpElement = qs(".hp");
            const pointsElement = qs(".points .value");
            const looserElement = qs("#looser");
            const rowsWrapper = qs(".tracks");
            const mainMenu = qs(".main-menu-screen");
            const gameScreen = qs(".game-screen");
            const time = qs(".time");

            const MINUTES_EASY = [0, 15, 30, 45];
            // const MINUTES_HARD = [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55];
            // const MINUTES_IMPOSSIBLE = Array(60)
            //     .fill()
            //     .map((_, i) => i);
            const TRACKS_NUM = 6;
            const HS_SERIALIZATION_KEY = "__time_flies__highscore";

            const BASE_TRACK_ANIMATION_TIME = 33000;
            const STOP_SPEEDUP_AT_ROUND = 15;
            const SPEEDUP_STEP = 300;

            function getTrackAnimationDuration(round) {
                const base = BASE_TRACK_ANIMATION_TIME - SPEEDUP_STEP * Math.min(round, STOP_SPEEDUP_AT_ROUND);
                return base + randomInt(5000) - 2500; // +/- 2500
            }

            const BASE_MAX_CLOCKS_PER_COLUMN = 1;
            const MAX_CLOCKS_PER_COLUMN_STEP = 0.2;
            const AT_MOST_CLOCKS_PER_COLUMN = 3;

            function getClocksPerColumn(round) {
                return Math.min(
                    AT_MOST_CLOCKS_PER_COLUMN,
                    Math.floor(BASE_MAX_CLOCKS_PER_COLUMN + MAX_CLOCKS_PER_COLUMN_STEP * round)
                );
            }

            let round = 1;
            let goalClocksCount = 0;
            let goneProperClocksCount = 0;

            function instantiateClock(hour, minutes) {
                const instance = instantiateTemplate("#t-clock");
                const clock = instance.children[0];
                clock.style.setProperty("--hour", hour);
                clock.style.setProperty("--minutes", minutes);
                return clock;
            }

            function fillHpElement(hp) {
                hpElement.innerHTML = Array(hp).fill("❤️").join("");
            }

            function closeYouLost() {
                looserElement.querySelector("#highscore").style.display = "none";
                looserElement.style.display = "none";
            }

            function showYouLost(points) {
                looserElement.style.display = null;
                const prevhs = localStorage.getItem(HS_SERIALIZATION_KEY);
                if (prevhs === null) {
                    localStorage.setItem(HS_SERIALIZATION_KEY, points);
                } else if (prevhs < points) {
                    looserElement.querySelector("#prev-hs").innerHTML = prevhs.toString();
                    looserElement.querySelector("#new-hs").innerHTML = points.toString();
                    looserElement.querySelector("#highscore").style.display = null;
                    localStorage.setItem(HS_SERIALIZATION_KEY, points);
                }
            }

            function resetTracks(tracks) {
                tracks.forEach((t) => (t.innerHTML = ""));
            }

            function reinstantiateTracks() {
                rowsWrapper.innerHTML = "";
                const newTracksInstance = instantiateTemplate("#t-tracks");
                rowsWrapper.append(...newTracksInstance.children);
            }

            function decreaseHP(hp, points, tracks) {
                playAudio(oofSfx);
                hp--;
                fillHpElement(hp);
                if (hp === 0) {
                    showYouLost(points);
                    resetTracks(tracks);
                }
                return hp;
            }

            function increasePoints(points) {
                playAudio(yaySfx);
                points++;
                goneProperClocksCount++;
                pointsElement.innerHTML = points;

                if (goneProperClocksCount == goalClocksCount) {
                    setTimeout(() => {
                        round = nextRound(points, round);
                    });
                }

                return points;
            }

            function startRound(trackLength, goal, carriedPoints = 0) {
                goalClocksCount = 0;
                goneProperClocksCount = 0;

                let hp = 3;
                let points = carriedPoints;

                mainMenu.style.display = "none";
                gameScreen.style.display = null;

                const { hour: ghour, minutes: gminutes } = goal;

                time.innerHTML = `${ghour}:${gminutes.toString().padStart(2, "0")}`;

                const matrixRows = Array(TRACKS_NUM)
                    .fill()
                    .map(() => Array(trackLength).fill(0));

                const clocksPerColumn = getClocksPerColumn(round);
                // debug
                console.group("clocks per column");
                console.log("clocksPerColumn", clocksPerColumn);
                // Losuję dla każdej kolumny, w którym wierszu ma się znaleźć zegarek.
                // Czyli dla każdej kolumny co najwyżej jeden wiersz będzie miał zegarek
                const clockCellsSet = new Set();
                for (let i = 0; i < trackLength; i++) {
                    const count = randomInt(clocksPerColumn) + 1; // [0..1] + 1 => [1..2]
                    // debug
                    console.log("count", count);
                    for (let j = 0; j < count; j++) {
                        // W teorii możemy count razy wylosować ten sam row.
                        const row = randomInt(TRACKS_NUM);
                        matrixRows[row][i] = 1;
                        clockCellsSet.add(`${row},${i}`);
                    }
                }
                console.groupEnd("clocks per column");

                // omg
                let goalCells = new Set(clockCellsSet);
                for (let i = goalCells.size; i > 3; i--) {
                    goalCells.delete([...goalCells.values()][randomInt(goalCells.size)]);
                }

                for (const g of goalCells) {
                    const [row, col] = g.split(",");
                    matrixRows[Number(row)][Number(col)] = 2;
                }

                const empty = document.createElement("div");
                empty.className = "empty";

                fillHpElement(hp);

                reinstantiateTracks();
                const tracks = document.querySelectorAll(".track");

                function onClockGoneOffScreen(intervId) {
                    clearInterval(intervId);
                    hp = decreaseHP(hp, points, tracks);
                    goneProperClocksCount++;
                    if (goneProperClocksCount == goalClocksCount && hp > 0) {
                        round = nextRound(points, round);
                    }
                }

                const clocksToCheckOffscreen = new Set();

                goalClocksCount = goalCells.size;
                matrixRows.forEach((row, idx) => {
                    for (const col of row) {
                        if (col === 1) {
                            const hour = Math.floor(Math.random() * 12) + 1;
                            const minutesIdx = Math.floor(Math.random() * MINUTES_EASY.length);
                            const minutes = MINUTES_EASY[minutesIdx];
                            const clock = instantiateClock(hour, minutes);
                            tracks[idx].appendChild(clock);

                            // There's also possibility that a "goal clock" will be generated here.
                            if (hour === ghour && minutes === gminutes) {
                                clocksToCheckOffscreen.add(clock);

                                const intervId = setInterval(() => {
                                    const bounds = clock.getBoundingClientRect();
                                    if (bounds.right < 0) {
                                        onClockGoneOffScreen(intervId);
                                    }
                                }, 16);

                                goalClocksCount++;
                            }
                        } else if (col === 2) {
                            const clock = instantiateClock(ghour, gminutes);
                            tracks[idx].appendChild(clock);
                            clocksToCheckOffscreen.add(clock);

                            // I had problems with observer, so I went with the setInterval method :/
                            const intervId = setInterval(() => {
                                const bounds = clock.getBoundingClientRect();
                                if (bounds.right < 0) {
                                    onClockGoneOffScreen(intervId);
                                }
                            }, 16);
                        } else {
                            tracks[idx].appendChild(empty.cloneNode());
                        }
                    }
                });

                function setupTracks(roundNumber) {
                    const reverseTracks = (() => {
                        if (roundNumber >= 4) {
                            const set = new Set([randomInt(6), randomInt(6), randomInt(6)]);
                            return [...set];
                        }
                        if (roundNumber >= 3) {
                            const set = new Set([randomInt(6), randomInt(6)]);
                            return [...set];
                        }
                        if (roundNumber >= 2) {
                            return [randomInt(6)];
                        }
                        return [];
                    })(round);

                    // console.group("tracks durations");
                    for (let i = 0; i < tracks.length; i++) {
                        const t = tracks[i];

                        let initialTranslate, goalTranslate;

                        if (reverseTracks.includes(i)) {
                            console.log(`track ${i} is reverse`);
                            initialTranslate = `translateX(calc(-${randomInt(5)}rem - ${Math.ceil(
                                t.getBoundingClientRect().width
                            )}px))`;
                            goalTranslate = `translateX(calc(100vw))`;
                        } else {
                            initialTranslate = `translateX(calc(100vw + ${randomInt(5)}rem))`;
                            goalTranslate = `translateX(${-Math.ceil(t.getBoundingClientRect().width)}px)`;
                        }

                        t.style.transform = initialTranslate;

                        const bounds = t.getClientRects();
                        const anim = [{ transform: initialTranslate }, { transform: goalTranslate }];
                        const duration = getTrackAnimationDuration(round);

                        // debug
                        // console.log(`track ${i} duration: ${duration}`);

                        const options = {
                            duration,
                            iterations: 1,
                            delay: randomInt(5000),
                        };

                        const animation = t.animate(anim, options);
                    }
                    // console.groupEnd("track durations");
                }

                setupTracks(round);

                window.handleClockClick = (instance) => {
                    const hour = instance.style.getPropertyValue("--hour");
                    const minutes = instance.style.getPropertyValue("--minutes");
                    if (hour == ghour && minutes == gminutes) {
                        points = increasePoints(points);
                        instance.parentNode.replaceChild(empty.cloneNode(), instance);
                    } else {
                        playAudio(wrongSfx);
                        instance.style.setProperty("--hover-shadow-color", "red");
                        instance.addEventListener(
                            "mouseleave",
                            () => {
                                instance.style.setProperty("--hover-shadow-color", "lime");
                            },
                            { once: true }
                        );
                    }
                };
            }

            window.play = function play(carriedPoints = 0) {
                const hour = randomInt(12) + 1;
                const minutes = MINUTES_EASY[randomInt(4)];
                startRound(20, { hour, minutes }, carriedPoints);
            };

            window.tryAgain = function tryAgain() {
                round = 1;

                closeYouLost();

                pointsElement.innerHTML = "0";
                play();
            };

            function nextRound(carriedPoints, round) {
                const r = document.querySelector(".round-no");
                round += 1;
                r.innerHTML = `Round ${round}`;
                r.classList.add("op1");
                setTimeout(() => {
                    r.classList.remove("op1");
                }, 1000);

                play(carriedPoints);

                return round;
            }
        </script>
    </body>
</html>
