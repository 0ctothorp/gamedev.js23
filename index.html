<!-- 
    Sounds on creative commons 0 license (public domain):
        oof: https://freesound.org/people/fotoshop/sounds/47356/
        wrong: https://freesound.org/people/Raclure/sounds/483598/
        yay: https://freesound.org/people/Higgs01/sounds/428156/

    Digital Dream font by Jakob Fischer (free for personal and commercial use): 
        https://www.1001fonts.com/digital-dream-font.html
        www.pizzadude.dk

    Heart SVG by Sergio Peña
        https://codepen.io/sergixnet/details/eZVpXa
 -->
<!DOCTYPE html>
<html>
    <head>
        <title>Time flies!</title>
        <link rel="preload" href="assets/digitaldream.ttf" as="font" type="font/ttf" crossorigin />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <link rel="stylesheet" href="./reset.css" />
        <link rel="stylesheet" href="./styles.css" />
        <style>
            @font-face {
                font-family: "Digital Dream";
                src: url("assets/digitaldream.ttf");
                font-display: block;
            }

            html,
            body {
                padding: 0;
                margin: 0;
                overflow: hidden;
                font-family: Verdana, Geneva, Tahoma, sans-serif;
                background-color: var(--saffron);
                color: var(--charcoal);
            }

            :root {
                --default-radius: 5rem;
                --default-diameter: calc(var(--default-radius) * 2);
                --clock-margin: 0 5rem;

                /* colors */
                /* palette link: https://coolors.co/palette/264653-2a9d8f-e9c46a-f4a261-e76f51 */
                --charcoal: hsla(197, 37%, 24%, 1);
                --persian-green: hsla(173, 58%, 39%, 1);
                --persian-green-lighter: hsla(173, 58%, 59%, 1);
                --saffron: hsla(43, 74%, 66%, 1);
                --sandy-brown: hsla(27, 87%, 67%, 1);
                --burnt-sienna: hsla(12, 76%, 61%, 1);
                --burnt-sienna-darker: hsla(12, 76%, 41%, 1);

                /* crazygames.io breakpoints */
                --cg-bp-w-lg: 1128px;
                --cg-bp-h-lg: 615px;
                --cg-bp-w-md: 938px;
                --cg-bp-h-md: 503px;
                --cg-bp-w-sm: 922px;
                --cg-bp-h-sm: 487px;

                font-size: 12px;
            }

            @media (max-width: 1128px) {
                :root {
                    font-size: 9px;
                }
            }

            @media (max-width: 938px) {
                :root {
                    font-size: 7.5px;
                }
            }

            * {
                box-sizing: border-box;
            }

            /*
            body.cg-bp-lg .screen {
                width: var(--cg-bp-w-lg) !important;
                height: var(--cg-bp-h-lg) !important;
                outline: 2px solid red;
                outline-offset: -2px;
            }

            body.cg-bp-md .screen {
                width: var(--cg-bp-w-md) !important;
                height: var(--cg-bp-h-md) !important;
                outline: 1px hsla(12, 76%, 41%, 1);
                outline: 2px solid red;
                outline-offset: -2px;
            }

            body.cg-bp-sm .screen {
                width: var(--cg-bp-w-sm) !important;
                height: var(--cg-bp-h-sm) !important;
                outline: 1px hsla(12, 76%, 41%, 1);
                outline: 2px solid red;
                outline-offset: -2px;
            }
            */
        </style>
        <script defer src="./js/consts.js"></script>
    </head>
    <body>
        <div class="screen main-menu-screen">
            <h1>Time flies!</h1>
            <p style="text-align: center; padding: 2rem 5rem; font-size: 2rem">
                Find all the clocks presenting the time from the upper center of your screen. Don't let the proper
                clocks slip by. You'll loose your hearts!
            </p>
            <button class="main-button" onclick="showDifficultyScreen()">Play</button>
        </div>

        <div class="screen difficulty-screen" style="display: none">
            <h1>Choose difficulty</h1>
            <div class="infos">
                <div data-difficulty="normal" class="difficulty-info" style="display: none">
                    Just normal mode. Clicking wrong clocks won't cause you trouble.
                </div>
                <div data-difficulty="hard" class="difficulty-info" style="display: none">
                    Stay alert - clicking on wrong clocks will cause you trouble.
                </div>
            </div>

            <button
                data-difficulty="normal"
                class="main-button"
                onclick="play({ cfg: DIFFICULTY_CONFIGS.NORMAL })"
                onmouseenter="DIFFICULTY_SCREEN_EVENT_HANDLERS.onDifficultyButtonMouseEnter(this)"
                onmouseleave="DIFFICULTY_SCREEN_EVENT_HANDLERS.onDifficultyButtonMouseLeave(this)"
            >
                Normal
            </button>
            <button
                data-difficulty="hard"
                class="main-button"
                onclick="play({ cfg: DIFFICULTY_CONFIGS.HARD })"
                onmouseenter="DIFFICULTY_SCREEN_EVENT_HANDLERS.onDifficultyButtonMouseEnter(this)"
                onmouseleave="DIFFICULTY_SCREEN_EVENT_HANDLERS.onDifficultyButtonMouseLeave(this)"
            >
                Hard
            </button>

            <button class="secondary-button" onclick="showScreen('main-menu')"><- Back</button>
        </div>

        <div class="screen game-screen" style="display: none">
            <div class="top-bar">
                <div class="hp"></div>
                <div class="time">3:15</div>
                <div class="points"><span class="value">0</span><span>points</span></div>
                <button id="pause-button" type="button" onclick="togglePause()">⏸️</button>
            </div>
            <div class="tracks-wrapper">
                <div class="tracks"></div>
            </div>
            <span class="round-no">Round 1</span>
        </div>

        <div id="looser-popup" class="popup" style="display: none">
            <div>You reached round #<span id="round-number"></span></div>
            <div>Your Score: <span id="score">0</span></div>
            <div id="highscore" style="display: none">
                <div>You have beaten your previous highscore of <span id="prev-hs">0</span></div>
            </div>
            <div id="try-again-wrapper">
                <button class="main-button" onclick="tryAgain(currentDifficultyCfg)">Try again</button>
                <button class="secondary-button" onclick="showDifficultyScreen()">Change difficulty</button>
            </div>
        </div>

        <div id="pause-popup" class="popup" style="display: none">
            <div>
                <h2>Pause</h2>
                <button class="main-button" onclick="backToMenu()">Back to menu</button>
                <button class="secondary-button" onclick="togglePause()">Close</button>
            </div>
        </div>

        <template id="t-clock">
            <div class="outer-circle" style="--radius: 4rem; --hour: 8; --minutes: 15" onclick="handleClockClick(this)">
                <div class="long-pointer"></div>
                <div class="short-pointer"></div>
            </div>
        </template>

        <template id="t-tracks">
            <div class="row">
                <div class="track"></div>
            </div>
            <div class="row">
                <div class="track"></div>
            </div>
            <div class="row">
                <div class="track"></div>
            </div>
            <div class="row">
                <div class="track"></div>
            </div>
            <div class="row">
                <div class="track"></div>
            </div>
            <div class="row">
                <div class="track"></div>
            </div>
        </template>

        <template id="t-heart">
            <svg
                version="1.1"
                xmlns="http://www.w3.org/2000/svg"
                xmlns:xlink="http://www.w3.org/1999/xlink"
                x="0px"
                y="0px"
                width="1.75em"
                height="1.75em"
                viewBox="0 0 640 480"
                xml:space="preserve"
            >
                <path
                    fill="var(--burnt-sienna)"
                    fill-rule="evenodd"
                    stroke-width="10%"
                    stroke="var(--burnt-sienna-darker)"
                    stroke-linejoin="round"
                    d="m212.88298,23.34021c-137.447098,-2.471161 -264.63855,212.481247 105.925735,435.340698c0.406281,-0.73114 1.968781,-0.73114 2.375031,0c382.517975,-230.048691 234.665131,-451.640178 92.625702,-434.390638c-55.372711,6.724489 -81.503326,37.45645 -93.813263,63.887968c-12.309845,-26.431519 -38.440552,-57.163479 -93.81308,-63.887968c-4.438782,-0.53927 -8.866302,-0.87019 -13.300125,-0.95006z"
                />
            </svg>
        </template>

        <script type="module">
            import { randomInt, instantiateTemplate, qs, playAudio, getEl, getEls } from "./js/utils.mjs";

            // TODO: make a progress bar for loading the assets?
            const yaySfx = new Audio("assets/yay.wav");
            const wrongSfx = new Audio("assets/wrong.mp3");
            const oofSfx = new Audio("assets/oof.wav");

            const hpElement = qs(".hp");
            const pointsElement = qs(".points .value");
            const looserElement = qs("#looser-popup");
            const rowsWrapper = qs(".tracks");
            const time = qs(".time");

            const mainMenu = qs(".main-menu-screen");
            const gameScreen = qs(".game-screen");
            const difficultyScreen = qs(".difficulty-screen");

            // setup event handlers for difficulty screen
            function setupDifficultyScreen() {
                const descriptions = getEls(".difficulty-info[data-difficulty]");

                function getDescriptionElFor(difficulty) {
                    return getEl(`.difficulty-info[data-difficulty="${difficulty}"]`);
                }

                window.DIFFICULTY_SCREEN_EVENT_HANDLERS = {
                    onDifficultyButtonMouseEnter: (btn) => {
                        const difficulty = btn.dataset.difficulty;
                        descriptions.forEach((x) => (x.style.display = "none"));
                        const descriptionEl = getDescriptionElFor(difficulty);
                        descriptionEl.style.display = null;
                    },
                    onDifficultyButtonMouseLeave: (btn) => {
                        const difficulty = btn.dataset.difficulty;
                        descriptions.forEach((x) => (x.style.display = "none"));
                    },
                };
            }

            setupDifficultyScreen();

            const MINUTES_EASY = [0, 15, 30, 45];
            // const MINUTES_HARD = [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55];
            // const MINUTES_IMPOSSIBLE = Array(60)
            //     .fill()
            //     .map((_, i) => i);
            const TRACKS_NUM = 6;
            const HS_SERIALIZATION_KEY = "__time_flies__highscore";

            const BASE_TRACK_ANIMATION_TIME = 33000;
            const STOP_SPEEDUP_AT_ROUND = 20;
            const SPEEDUP_STEP = 350;

            /** @typedef {{
             *      isPaused: boolean
             *      trackAnimations: Animation[]
             * }} GameState */

            /**
             * @typedef { "main-menu" | "difficulty" | "game" } Screen
             */

            function getInitialGameState() {
                // TODO: move the rest of the fragmented state inside here
                return {
                    /** @type {Screen} */
                    screen: "main-menu",
                    isPaused: false,
                    /** @type {Animation[]} */
                    trackAnimations: [],
                };
            }

            /** @type {GameState} */
            const GAME_STATE = getInitialGameState();

            /** @param {GameState} gameState */
            function pause(gameState) {
                if (gameState.screen !== "game") return;
                gameState.isPaused = true;
                for (const anim of gameState.trackAnimations) {
                    anim.pause();
                }
            }

            /** @param {GameState} gameState */
            function unPause(gameState) {
                if (gameState.screen !== "game") return;
                gameState.isPaused = false;
                for (const anim of gameState.trackAnimations) {
                    anim.play();
                }
            }

            /** @param {GameState} gameState */
            function togglePause(gameState) {
                if (gameState.screen !== "game") return;
                if (gameState.isPaused) {
                    unPause(gameState);
                    getEl("#pause-popup").style.display = "none";
                } else {
                    pause(gameState);
                    getEl("#pause-popup").style.display = null;
                }
            }

            window.togglePause = () => togglePause(GAME_STATE);

            /**
             * @param {GameState} gameState
             * @param {Screen} screen
             */
            function changeScreen(gameState, screen) {
                gameState.screen = screen;
                const screens = getEls(".screen");
                for (const s of screens) s.style.display = "none";
                getEl(`.${screen}-screen`).style.display = null;
            }

            window.showScreen = (name) => changeScreen(GAME_STATE, name);
            window.backToMenu = () => {
                changeScreen(GAME_STATE, "main-menu");
                // simple way of stopping the game
                getEl(".tracks").innerHTML = "";
                // some popups might need some internal elements to hide also
                getEls(".popup").forEach((x) => (x.style.display = "none"));
            };

            function getTrackAnimationDuration(round) {
                const base = BASE_TRACK_ANIMATION_TIME - SPEEDUP_STEP * Math.min(round, STOP_SPEEDUP_AT_ROUND);
                return base + randomInt(5000) - 2500; // +/- 2500
            }

            const BASE_MAX_CLOCKS_PER_COLUMN = 1;
            const MAX_CLOCKS_PER_COLUMN_STEP = 0.2;
            const AT_MOST_CLOCKS_PER_COLUMN = 3;

            function getClocksPerColumn(round) {
                return Math.min(
                    AT_MOST_CLOCKS_PER_COLUMN,
                    Math.floor(BASE_MAX_CLOCKS_PER_COLUMN + MAX_CLOCKS_PER_COLUMN_STEP * round)
                );
            }

            let round = 1;
            let goalClocksCount = 0;
            let goneProperClocksCount = 0;

            function instantiateClock(hour, minutes) {
                const instance = instantiateTemplate("#t-clock");
                const clock = instance.children[0];
                clock.style.setProperty("--hour", hour);
                clock.style.setProperty("--minutes", minutes);
                return clock;
            }

            function fillHpElement(hp) {
                const instance = instantiateTemplate("#t-heart");
                const elements = [instance];
                for (let i = 1; i < hp; i++) {
                    elements.push(instance.cloneNode(true));
                }
                hpElement.innerHTML = "";
                hpElement.append(...elements);
            }

            function closeYouLost() {
                getEl("#highscore").style.display = "none";
                looserElement.style.display = "none";
            }

            function showYouLost(points) {
                looserElement.style.display = null;

                getEl("#round-number").innerHTML = round;
                getEl("#score").innerHTML = points;

                const prevhs = localStorage.getItem(HS_SERIALIZATION_KEY);
                if (prevhs === null) {
                    localStorage.setItem(HS_SERIALIZATION_KEY, points);
                } else if (prevhs < points) {
                    getEl("#prev-hs").innerHTML = prevhs.toString();
                    getEl("#new-hs").innerHTML = points.toString();
                    getEl("#highscore").style.display = null;
                    localStorage.setItem(HS_SERIALIZATION_KEY, points);
                }
            }

            function resetTracks(tracks) {
                tracks.forEach((t) => (t.innerHTML = ""));
            }

            function reinstantiateTracks() {
                rowsWrapper.innerHTML = "";
                const newTracksInstance = instantiateTemplate("#t-tracks");
                rowsWrapper.append(...newTracksInstance.children);
            }

            function decreaseHP(hp, points, tracks) {
                playAudio(oofSfx);
                hp--;
                fillHpElement(hp);
                if (hp === 0) {
                    showYouLost(points);
                    resetTracks(tracks);
                }
                return hp;
            }

            function increasePoints(points) {
                playAudio(yaySfx);
                points++;
                goneProperClocksCount++;
                pointsElement.innerHTML = points;

                if (goneProperClocksCount == goalClocksCount) {
                    setTimeout(() => {
                        round = nextRound(points, round);
                    });
                }

                return points;
            }

            function isOutOfScreen(clock) {
                if (clock.dataset.disabled) return false;

                const bounds = clock.getBoundingClientRect();
                return (
                    (clock.dataset.reverse && bounds.left > window.innerWidth) ||
                    (!clock.dataset.reverse && bounds.right < 0)
                );
            }

            /**
             * @param { { punishOnMistake: boolean } } cfg
             */
            function startRound(trackLength, goal, carriedPoints = 0, cfg) {
                const { punishOnMistake } = cfg;

                goalClocksCount = 0;
                goneProperClocksCount = 0;

                let hp = 3;
                let points = carriedPoints;

                const { hour: ghour, minutes: gminutes } = goal;

                time.innerHTML = `${ghour}:${gminutes.toString().padStart(2, "0")}`;

                const matrixRows = Array(TRACKS_NUM)
                    .fill()
                    .map(() => Array(trackLength).fill(0));

                const clocksPerColumn = getClocksPerColumn(round);
                // debug
                // console.group("clocks per column");
                // console.log("clocksPerColumn", clocksPerColumn);
                // Losuję dla każdej kolumny, w którym wierszu (i w ilu) ma się znaleźć zegarek.
                // Czyli dla każdej kolumny co najwyżej jeden wiersz będzie miał zegarek
                const clockCellsSet = new Set();
                for (let i = 0; i < trackLength; i++) {
                    const count = randomInt(clocksPerColumn) + 1; // [0..1] + 1 => [1..2]
                    // debug
                    // console.log("count", count);
                    for (let j = 0; j < count; j++) {
                        // W teorii możemy count razy wylosować ten sam row.
                        const row = randomInt(TRACKS_NUM);
                        matrixRows[row][i] = 1;
                        clockCellsSet.add(`${row},${i}`);
                    }
                }
                // console.groupEnd("clocks per column");

                // omg
                let goalCells = new Set(clockCellsSet);
                for (let i = goalCells.size; i > 3; i--) {
                    goalCells.delete([...goalCells.values()][randomInt(goalCells.size)]);
                }

                for (const g of goalCells) {
                    const [row, col] = g.split(",");
                    matrixRows[Number(row)][Number(col)] = 2;
                }

                const empty = document.createElement("div");
                empty.className = "empty";

                fillHpElement(hp);

                reinstantiateTracks();
                const tracks = document.querySelectorAll(".track");

                function onClockGoneOffScreen(intervId) {
                    clearInterval(intervId);
                    hp = decreaseHP(hp, points, tracks);
                    goneProperClocksCount++;
                    if (goneProperClocksCount == goalClocksCount && hp > 0) {
                        round = nextRound(points, round);
                    }
                }

                const clocksToCheckOffscreen = new Set();

                goalClocksCount = goalCells.size;
                matrixRows.forEach((row, idx) => {
                    for (const col of row) {
                        if (col === 1) {
                            const hour = Math.floor(Math.random() * 12) + 1;
                            const minutesIdx = Math.floor(Math.random() * MINUTES_EASY.length);
                            const minutes = MINUTES_EASY[minutesIdx];
                            const clock = instantiateClock(hour, minutes);
                            tracks[idx].appendChild(clock);

                            // There's also possibility that a "goal clock" will be generated here.
                            if (hour === ghour && minutes === gminutes) {
                                clocksToCheckOffscreen.add(clock);

                                const intervId = setInterval(() => {
                                    if (isOutOfScreen(clock)) {
                                        onClockGoneOffScreen(intervId);
                                    }
                                }, 16);

                                goalClocksCount++;
                            }
                        } else if (col === 2) {
                            const clock = instantiateClock(ghour, gminutes);
                            tracks[idx].appendChild(clock);
                            clocksToCheckOffscreen.add(clock);

                            // I had problems with observer, so I went with the setInterval method :/
                            const intervId = setInterval(() => {
                                if (isOutOfScreen(clock)) {
                                    onClockGoneOffScreen(intervId);
                                }
                            }, 16);
                        } else {
                            tracks[idx].appendChild(empty.cloneNode());
                        }
                    }
                });

                function setupTracks(roundNumber) {
                    const reverseTracksIndices = (() => {
                        if (roundNumber >= 18) {
                            const set = new Set([randomInt(6), randomInt(6), randomInt(6)]);
                            return [...set];
                        }
                        if (roundNumber >= 11) {
                            const set = new Set([randomInt(6), randomInt(6)]);
                            return [...set];
                        }
                        if (roundNumber >= 5) {
                            return [randomInt(6)];
                        }
                        return [];
                    })(round);

                    // console.group("tracks durations");
                    for (let i = 0; i < tracks.length; i++) {
                        const track = tracks[i];

                        let initialTranslate, goalTranslate;

                        if (reverseTracksIndices.includes(i)) {
                            // console.log(`track ${i} is reverse`);
                            initialTranslate = `translateX(calc(-${randomInt(5)}rem - ${Math.ceil(
                                track.getBoundingClientRect().width
                            )}px))`;
                            goalTranslate = `translateX(calc(100vw))`;
                            for (const c of track.children) c.dataset.reverse = true;
                        } else {
                            initialTranslate = `translateX(calc(100vw + ${randomInt(5)}rem))`;
                            goalTranslate = `translateX(${-Math.ceil(track.getBoundingClientRect().width)}px)`;
                        }

                        track.style.transform = initialTranslate;

                        const bounds = track.getClientRects();
                        const trackAnimation = [{ transform: initialTranslate }, { transform: goalTranslate }];
                        const duration = getTrackAnimationDuration(round);

                        // debug
                        // console.log(`track ${i} duration: ${duration}`);

                        const options = {
                            duration,
                            iterations: 1,
                            delay: randomInt(5000),
                        };

                        const animation = track.animate(trackAnimation, options);
                        GAME_STATE.trackAnimations.push(animation);
                    }
                    // console.groupEnd("track durations");
                }

                setupTracks(round);

                window.handleClockClick = (instance) => {
                    const hour = instance.style.getPropertyValue("--hour");
                    const minutes = instance.style.getPropertyValue("--minutes");
                    if (hour == ghour && minutes == gminutes) {
                        points = increasePoints(points);
                        // instance.parentNode.replaceChild(empty.cloneNode(), instance);
                        instance.style.visibility = "hidden";
                        instance.style.pointerEvents = "none";
                        instance.dataset.disabled = true;
                    } else {
                        playAudio(wrongSfx);
                        instance.style.setProperty("--hover-shadow-color", "red");
                        instance.addEventListener(
                            "mouseleave",
                            () => {
                                instance.style.setProperty("--hover-shadow-color", "lime");
                            },
                            { once: true }
                        );

                        // console.log({ cfg, punishOnMistake });

                        if (punishOnMistake) {
                            hp = decreaseHP(hp, points, tracks);
                        }
                    }
                };
            }

            window.showDifficultyScreen = function showDifficultyScreen() {
                closeYouLost();
                changeScreen(GAME_STATE, "difficulty");
            };

            window.play = function play({ carriedPoints = 0, cfg }) {
                // TODO: store cfg in game state
                window.currentDifficultyCfg = cfg;

                changeScreen(GAME_STATE, "game");

                const hour = randomInt(12) + 1;
                const minutes = MINUTES_EASY[randomInt(4)];
                startRound(20, { hour, minutes }, carriedPoints, cfg);
            };

            window.tryAgain = function tryAgain(cfg) {
                round = 1;

                closeYouLost();

                pointsElement.innerHTML = "0";
                play({ cfg });
            };

            function nextRound(carriedPoints, round) {
                const r = document.querySelector(".round-no");
                round += 1;
                r.innerHTML = `Round ${round}`;
                r.classList.add("op1");
                setTimeout(() => {
                    r.classList.remove("op1");
                }, 1000);

                play({ carriedPoints, cfg: window.currentDifficultyCfg });

                return round;
            }

            addEventListener("keyup", (ev) => {
                if (ev.key === "Escape") {
                    togglePause(GAME_STATE);
                }
            });
        </script>
    </body>
</html>
